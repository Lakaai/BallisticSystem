using LinearAlgebra
using ForwardDiff
using Optim
using Infiltrator

include("measurement.jl")

@enum UpdateMethod AFFINE UNSCENTED NEWTONTRUSTEIG BFGSTRUSTSQRTINV

const p0 = 101.325e3       # Air pressure at sea level [Pa]
const M  = 0.0289644       # Molar mass of dry air [kg/mol]
const R  = 8.31447         # Gas constant [J/(mol¬∑K)]
const L  = 0.0065          # Temperature gradient [K/m]
const T0 = 288.15          # Temperature at sea level [K]
const g  = 9.81            # Acceleration due to gravity [m/s¬≤]
time_ = 0                  # Previous time stamp 

# Laplace Aproximation ‚Ñê = ‚à´‚Çìf(x)dx ‚âà f(x*) ‚àödet(2*œÄ*P)
# x* = argmax f(x)

function predict(time::Any, density::Gaussian, update_method::UpdateMethod; sqrt=sqrt)
    global time_
    dt = time - time_   # Update the time increment
    time_= time         # Update the previous time

    @assert dt >= 0 "dt must be non-negative"

    if dt == 0  
        return density
    end 

    # Define process noise covariance Q
    Q = Matrix(Diagonal([1e-20, 25e-12, 0.0]))  # [velocity, drag coeff, altitude (no noise)]

    Œºùë• = density.mean
    process_model = Œºùë• -> rk4_step(Œºùë•, dt)
    println("================================================")
    println("Predicting....")
    println("================================================")
    if sqrt 

        if update_method == UNSCENTED

            predicted_density = unscented_transform(process_model, density; sqrt=true)
            predicted_density = from_moment(predicted_density.mean, predicted_density.covariance + Q)   # Add process noise after transformation

        elseif update_method == AFFINE

            predicted_density = affine_transform(process_model, density; sqrt=true)
            predicted_density = from_moment(predicted_density.mean, predicted_density.covariance + Q)   # Add process noise after transformation

        else
            error("Invalid prediction method: $update_method")
        end  

    else

        if update_method == UNSCENTED

            predicted_density = unscented_transform(process_model, density; sqrt=false)
            predicted_density = from_moment(predicted_density.mean, predicted_density.covariance + Q)   # Add process noise after transformation

        elseif update_method == AFFINE

            predicted_density = affine_transform(process_model, density; sqrt=false)
            predicted_density = from_moment(predicted_density.mean, predicted_density.covariance + Q)   # Add process noise after transformation

        else
            error("Invalid prediction method: $update_method")
        end  

    end 

    return predicted_density

end 


"""
"""
function unscented_transform(func::Any, density::Gaussian; sqrt=sqrt)

        Œºùë• = density.mean
        Œ£ùë• = density.covariance
        L = length(Œºùë•)
        
        # UKF parameters
        Œ∫ = 0
        Œ± = 1                   # originally 0.2
        Œ≤ = 2
        Œª = Œ±^2 * (L + Œ∫) - L

        Œ£ùë• = 0.5 * (Œ£ùë• + Œ£ùë•')                   # force symmetry
        # Add regularization for numerical stability
        Œµ = 1e-3
        # Œ£ùë•_reg = Œ£ùë• + Œµ * I
        # @show Œ£ùë•_reg

        Œ£ùë•_reg = Œ£ùë• + Œµ * I
        S‚Çì = cholesky((L + Œª) * Œ£ùë•_reg).L
        println("================================================")
        println("Eigenvalues sigma reg: ", eigvals((L + Œª) * Œ£ùë•_reg))
        println("Eigenvalues sigma (L + Œª) * Œ£ùë•: ", eigvals((L + Œª) * Œ£ùë•))
        println("================================================")
        S‚Çì = cholesky((L + Œª) * Œ£ùë•).L
        ùõò = zeros(Float64, L, 2L + 1)
        ùõò[:, 1] = Œºùë•
        
        for i in 1:L
            ùõò[:, i+1] = Œºùë• + S‚Çì[:, i]
            ùõò[:, i+1+L] = Œºùë• - S‚Çì[:, i]
        end
        
        # Weights 
        ùëæ·µê = zeros(2L + 1)
        ùëæ·∂ú = zeros(2L + 1)
        ùëæ·µê[1] = Œª / (L + Œª)
        ùëæ·∂ú[1] = Œª / (L + Œª) + (1 - Œ±^2 + Œ≤)
        ùëæ·µê[2:end] .= 1 / (2 * (L + Œª))
        ùëæ·∂ú[2:end] .= 1 / (2 * (L + Œª))

        # Transform sigma points through measurement model
        # @show ùõò[:, 1]
        Œºùë¶ = func(ùõò[:, 1])
        nùë¶ = length(Œºùë¶)
        ùí¥ = zeros(nùë¶, 2L + 1)    # Assuming scalar measurements

        # @show Œºùë¶
        # @show Œ£ùë¶
        ùí¥[:, 1] = Œºùë¶
        for i in 2:(2L + 1)
            
            
           
            
            ùí¥[:, i] = func(ùõò[:, i])
            # @show ùí¥[:, i]
        end
        # @show size(ùí¥)
        # Compute measurement statistics

        # Œºùë¶ = sum(ùëæ·µê[i] * ùí¥[i] for i in 1:(2L + 1))
        # Œ£ùë¶ = sum(ùëæ·∂ú[i] * (ùí¥[i] - Œºùë¶)^2 for i in 1:(2L + 1))
        
        # # Compute cross-covariance (state-measurement)
        # Œ£ùë•ùë¶ = sum(ùëæ·∂ú[i] * (ùõò[:, i] - Œºùë•) * (ùí¥[i] - Œºùë¶) for i in 1:(2L + 1))

        # Clean and efficient way to compute the mean and covariance 

        Œºùë¶ = ùí¥ * ùëæ·µê
        dY = ùí¥ .- Œºùë¶
        Œ£ùë¶ = dY * Diagonal(ùëæ·∂ú) * dY'
        Œ£ùë¶ = 0.5 * (Œ£ùë¶ + Œ£ùë¶')
        return from_moment(Œºùë¶, Œ£ùë¶)
end 


"""
    This method transforms the Gaussian distribution p(ùë•) through a nonlinear function y = f(ùë•) by 
    propogating information through the affine transformation. It returns a new Gaussian distribution
    representing p(ùë¶)

    # Arguments
    - `func`: Current state vector.
    - `density`: The Gaussian distribution to be propogated through the nonlinear function.

    # Returns
    - `p(ùë¶)`: The transformed Gaussian distribution.

"""
function affine_transform(func::Any, density::Gaussian; sqrt=sqrt)

    # TODO: Implement noise increment if required. 
    # TODO: Should affine transform be able work on any function or only functions with signature(x, dt)?

    if sqrt
        Œºx = density.mean
        Sx = density.covariance

        # Evalute ‚àÇh(x)/‚àÇx at x = Œº, that is the Jacobian of h evalutated at Œº
        C = ForwardDiff.jacobian(func, Œºx)

        # Evalute h(Œºx) to obtain Œºy 
        Œºy = func(Œºx, dt)

        # Propogate the covariance 
        Sy = Sx*C' 
    
        # Ensure Sy is upper triangular via QR decomposition
        Q, R1 = qr(Sy)
        Sy_upper = UpperTriangular(Sy)

        return from_sqrt_moment(Œºy, Sy_upper) 

    else 
        Œºx = density.mean
        Œ£x = density.covariance

        J = ForwardDiff.jacobian(func, Œºx)

        Œºy = func(Œºx)
        Œ£y = J * Œ£x * J'

        @assert isapprox(Œ£y, Œ£y', rtol=1e-6) "Covariance not symmetric"
        @assert all(eigvals(Œ£y) .>= -1e-10) "Covariance not positive semi-definite"

        return from_moment(Œºy, Œ£y)
    end 
end    

"""
    rk4_step(x::Vector{Float64}, dt::Float64) -> Vector{Float64}

Propagates the system state `x‚Çñ` forward one time step using the classical Runge-Kutta 4 (RK4) integration method.
Map x[k] to x[k+1] using RK4 integration
This version assumes a **deterministic process model** (`dx = f(x) dt`) with no process noise.

# Arguments
- `x‚Çñ`: Current state vector.
- `dt`: Time step duration.

# Returns
- `x‚Çñ‚Çä‚ÇÅ`: Estimated state at the next time step.
"""
function rk4_step(x‚Çñ::Any, dt::Any)
    k1 = dynamics(x‚Çñ)
    k2 = dynamics(x‚Çñ .+ 0.5 .* dt .* k1)
    k3 = dynamics(x‚Çñ .+ 0.5 .* dt .* k2)
    k4 = dynamics(x‚Çñ .+ dt .* k3)

    x‚Çñ‚Çä‚ÇÅ = x‚Çñ .+ dt/6 .* (k1 .+ 2k2 .+ 2k3 .+ k4)

    return x‚Çñ‚Çä‚ÇÅ 
end 
  
"""
    rk4_sde_step(xdw::Vector{Float64}, dt::Float64, idxQ::Vector{Int}, augmented_dynamics::Function) -> (Vector{Float64}, Matrix{Float64})

Propagates the augmented state `[x‚Çñ; Œîw‚Çñ]` forward one time step using an RK4 method for stochastic systems with additive noise.

This mirrors a typical **SDE-based system update** used in filters that compute Jacobians with respect to both the state and process noise. The function supports:
- RK4 integration of the state and its derivatives.
- Process noise influence using indices in `idxQ`.
- Jacobian computation for use in filters like the EKF.

# Arguments
- `xdw`: Augmented input vector `[x; dw_subset]`, where `x` is the state and `dw_subset` is a subset of the process noise.
- `dt`: Fixed time step.
- `idxQ`: Indices specifying which noise components affect which states.
- `augmented_dynamics`: Function computing the augmented system dynamics `f(X)`, where `X` contains the state and partial derivatives.

# Returns
- `X‚Çñ‚Çä‚ÇÅ` The object that contains [x‚Çñ‚Çä‚ÇÅ ‚àÇx‚Çñ‚Çä‚ÇÅ/‚àÇx‚Çñ  ‚àÇx‚Çñ‚Çä‚ÇÅ/‚àÇŒîw‚Çñ].
"""
function rk4_sde_step(x‚Çñ::Any, Œît::Any)

    nx = length(xdw) - length(idxQ)
    nq = length(idxQ)

    x = xdw[1:nx]
    dw = zeros(nx)
    dw[idxQ] .= xdw[nx+1:end]

    # Augmented matrices: [x‚Çñ‚Çä‚ÇÅ ‚àÇx‚Çñ‚Çä‚ÇÅ/‚àÇx‚Çñ  ‚àÇx‚Çñ‚Çä‚ÇÅ/‚àÇŒîw‚Çñ]
    X‚Çñ  = hcat(x, I(nx), zeros(nx, nx))
    ŒîW‚Çñ = hcat(dw, zeros(nx, nx), I(nx))

    F1 = augmented_dynamics(X‚Çñ)
    F2 = augmented_dynamics(X‚Çñ .+ (F1 .* Œît .+ ŒîW‚Çñ) ./ 2)
    F3 = augmented_dynamics(X‚Çñ .+ (F2 .* Œît .+ ŒîW‚Çñ) ./ 2)
    F4 = augmented_dynamics(X‚Çñ .+ F3 .* Œît .+ ŒîW‚Çñ)

    X‚Çñ‚Çä‚ÇÅ = X‚Çñ .+ (F1 .+ 2 .* F2 .+ 2 .* F3 .+ F4) .* (Œît / 6) .+ Œîw‚Çñ

    # Extract Jacobian
    J = hcat(X‚Çñ‚Çä‚ÇÅ[:, 2:nx+1], X‚Çñ‚Çä‚ÇÅ[:, nx+1 .+ idxQ])

    return X‚Çñ‚Çä‚ÇÅ[:, 1], J
end 
    

# Evaluate f(x) from the SDE dx = f(x)*dt + dw
function dynamics(x::Any; jacobian=false, hessian=false)

    # Extract state variables
    h = x[1]
    v = x[2]
    c = x[3]
    
    f = similar(x)

    # Calculate temperature at altitude h
    T = T0 - L * h
    
    d = ((0.5 * M * p0) / R) * (1 / T) * (1 - L * h / T0)^(g * M / (R * L)) * v^2 * c

    # Set f according to the dynamics equations
    f[1] = v;                 # dh/dt = v
    f[2] = d - g;             # dv/dt = d - g
    f[3] = 0;                 # dc/dt = 0 (drag coefficient is constant)

    # If the neither the jacobian or hessian is required then only return f
    if !jacobian && !hessian
        return f
    end 

    if jacobian
        # Calculate partial derivatives
        dd_dh = ((0.5 * M * p0) / R) * v^2 * c * (
            (L / (T^2)) * (1 - L * h / T0)^(g * M / (R * L)) -
            (g * M / (R * T0)) * (1 - L * h / T0)^((g * M / (R * L)) - 1) / T)
        dd_dv = 2 * d / v
        dd_dc = d / c

        # Resize J to the correct size and fill in values
        J = zeros(length(f), length(x))

        J[1, 2] = 1.0
        J[2, 1] = dd_dh
        J[2, 2] = dd_dv
        J[2, 3] = dd_dc
        # J[3, :] stays zero
        
        if !hessian
            return f, J
        end 

    if hessian
        # TODO Implement hessian
        error("Hessian not yet implemented")
    end 

end 

    return f
end

# Evaluate F(X) from dX = F(X)*dt + dW
function augmentedDynamics(X::Any)
    @assert size(X, 1) > 0 "X must have at least one row"
    nx = size(X, 1)

    x = X[:, 1]
    f, J = dynamics(x, jacobian=true)

    @assert size(f, 1) == nx "f must have nx rows"
    @assert size(J, 1) == nx && size(J, 2) == nx "J must be nx by nx"

    dX = hcat(f, J * X[:, 2:end])
    return dX
end 

"""
    cost_function_factory(density::Gaussian, measurement)

The mean and covariance values must be available at the time of evaluation of the cost function. However, the cost function 
passed to the optimiser requires a function signature of f(x), therefore we will create a function factory to create a cost function 
with the required signature whilst still having access to the mean and covaraince values. 

In general a `factory` is an object for creating other objects, in this case it is a function that returns another function.

# Arguments
- `density` The system density.
- `measurement` The current measurement vector.

# Returns
- A function with signature f(x) that can be passed to the optimiser.

"""
function cost_function_factory(density::Gaussian, measurement)
    return function(x) # Returns a cost function f(x) which has the required signature for the optimiser
        logprior = log_sqrt_pdf(x, density)

        # You must define this based on your measurement model
        loglik, _ = logLikelihood(x, measurement; grad=true)

         # Return a scalar cost (negative log-likelihood (the measurement cost) + log-prior (the prediction cost))
        return -(logprior + loglik) # Return ‚àílogp(x‚à£z) = -(logp(x) + logp(z‚à£x))
    end
end


function measurement_update_bfgs(density::Gaussian, measurement::Any)
    x0 = density.mean
    S = density.covariance

    df = TwiceDifferentiable(cost_function_factory(density, measurement), x0, autodiff = :forward) # Store and reuse gradient and hessian 
    res = optimize(df, x0, BFGS())
    # @assert res.converged "res has not converged"

    x_map = Optim.minimizer(res)

    # Posterior sqrt covariance approximation (naive)
    H = ForwardDiff.hessian(cost_function_factory(density, measurement), x_map)
    @show H
    # H_inv = inv(H)
    # Q, R = qr(H_inv) # Perform QR decomposition
    F = cholesky(H)   # H = F'U F, F.U is upper triangular
    S = Matrix(inv(F.U))      # S * S' = H^{-1}
    
    return Gaussian(x_map, S)
    # ‚Ñê = ‚à´‚Çìf(x)dx ‚âà f(x*) ‚àödet(2*œÄ*P) Laplace approximation
end 

function measurement_update_unscented(density::Gaussian, measurement::Any; sqrt=sqrt)
    
    if sqrt
        # Form the joint probability density ùëù(ùë•‚Çñ, ùë¶‚Çñ | ùë¶‚ÇÅ...ùë¶‚Çñ‚Çã‚ÇÅ), that is the probability of the state ùë•‚Çñ and the measurement ùë¶‚Çñ given all past measurements ùë¶‚ÇÅ, ùë¶‚ÇÇ, ..., ùë¶‚Çñ‚Çã‚ÇÅ
        # new_density = unscented_transform(predict_measurement, density; sqrt=true)
        error("Not implemented yet") # TODO: Implement square root covariance
        # Condition on the measurement ùë¶‚Çñ to form the posterior density ùëù(ùë•‚Çñ | ùë¶‚Çñ)

        # Return the posterior density ùëù(ùë•‚Çñ | ùë¶‚Çñ)
        return from_sqrt_moment(Œº, S)
        
    else 

        # # Measurement noise covariance
        # R = Matrix(Diagonal([50.0^2]))  # Adjust as needed
        # R = 50
        noise_density = Gaussian(0, Matrix(Diagonal([50.0^2])))

        # density = join(density, noise_density)

        # func = Œºùë• -> measurement(Œºùë•)
        transformed_density = unscented_transform(augmented_predict_measurement, density; sqrt=false)
        @show transformed_density.mean

        L = length(density.mean)
        Œº = transformed_density.mean
        Œ£ = transformed_density.covariance
        
        R = 50.0^2                    # pick your variance
        Œ£[L+1:end, L+1:end] .+= R     # measurement block
        Œ£ = 0.5 .* (Œ£ .+ Œ£')          # symmetrize
        
        transformed_density = from_moment(Œº, Œ£)
        
        # Œºx = Œº[1:L]; Œºy = Œº[L+1:end]
        # Œ£xx = Œ£[1:L, 1:L]; Œ£xy = Œ£[1:L, L+1:end]; Œ£yy = Œ£[L+1:end, L+1:end]
        # # R = 50.0^2
        # K = Œ£xy / (Œ£yy)
        # yhat = Œºy[1]
        # innov = measurement[1] - yhat
        # @show Œºx[1], yhat, measurement[1], innov, Œ£xy[1], K[1]
        # Œºx_expected = Œºx .+ K * innov
        # Œ£x_expected = Œ£xx .- K * Œ£yy * K'
        # @show Œºx_expected
        # @show Œ£x_expected

        updated_density = condition(transformed_density, 1:3, 4, measurement; sqrt=false)

        Œº_updated = updated_density.mean
        Œ£_updated = updated_density.covariance
        println("Updated mean after condition: ", Œº_updated)
        println("Updated covariance after condition: ", Œ£_updated)
        return from_moment(Œº_updated, Œ£_updated)

        # My CODE

        # Œ£ùë•ùë¶ = sum(ùëæ·∂ú[i] * (ùõò[:, i] - Œºùë•) * (ùí¥[i] - Œºùë¶) for i in 1:(2L + 1)) # Cross-covariance check should a trasnpose be in here 

        # # But then you MUST do the Kalman update:
        # K = Œ£ùë•ùë¶ / Œ£ùë¶                                    # Kalman gain
        # Œº_updated = Œºùë• + K * (measurement .- Œºùë¶)        # Updated state mean
        # Œ£_updated = Œ£ùë• - K * Œ£ùë¶ * K'                    # Updated state covariance
        
    end 
end 

function measurement_update_affine(density::Gaussian, measurement::Any; sqrt=false)
    if sqrt
        error("Not implemented yet") # TODO: Implement square root affine update
    else 

        Œº_pred = density.mean
        Œ£_pred = density.covariance
        
        # Use gradient since the measurement function returns a scalar
        H = ForwardDiff.jacobian(predict_measurement, Œº_pred)
        R = Matrix(Diagonal([50.0^2])) # Measurement noise covariance

        K = Œ£_pred * H' / (H * Œ£_pred * H' + R)
        Œº = Œº_pred + K * (measurement - predict_measurement(Œº_pred))
        Œ£ = (I - K * H) * Œ£_pred

        return from_moment(Œº, Œ£) 
    end 
end 

function update(density::Gaussian, measurement::Any, update_method::UpdateMethod; sqrt=false)
    if update_method == BFGSTRUSTSQRTINV
        density = measurement_update_bfgs(density, measurement)
    elseif update_method == UNSCENTED
        density = measurement_update_unscented(density, measurement; sqrt=false) 
    elseif update_method == AFFINE
        density = measurement_update_affine(density, measurement; sqrt=false)
    elseif update_method == NEWTONTRUSTEIG
        error("Not implemented yet")
        # TODO: density = measurement_update_newtontrusteig(density, measurement)
    else
        error("Invalid update method: $update_method")
    end  
end  